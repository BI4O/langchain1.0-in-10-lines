# ğŸš€ LangGraph å‰åç«¯äº¤äº’å­¦ä¹ æŒ‡å—

æœ¬æŒ‡å—è¯¦ç»†è®²è§£å¦‚ä½•å®ç°å‰ç«¯Reactåº”ç”¨ä¸åç«¯LangGraphæœåŠ¡çš„å®Œæ•´äº¤äº’ï¼Œé€‚åˆæƒ³è¦æ·±å…¥å­¦ä¹ å’Œè‡ªå·±å®ç°çš„å¼€å‘è€…ã€‚

## ğŸ“š ç›®å½•

1. [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
2. [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
3. [ç¯å¢ƒå‡†å¤‡](#ç¯å¢ƒå‡†å¤‡)
4. [åç«¯é…ç½®](#åç«¯é…ç½®)
5. [å‰ç«¯å®ç°](#å‰ç«¯å®ç°)
6. [äº¤äº’æµç¨‹è¯¦è§£](#äº¤äº’æµç¨‹è¯¦è§£)
7. [å…³é”®ä»£ç åˆ†æ](#å…³é”®ä»£ç åˆ†æ)
8. [è‡ªå·±åŠ¨æ‰‹å®ç°](#è‡ªå·±åŠ¨æ‰‹å®ç°)
9. [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

## ğŸ—ï¸ æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   React å‰ç«¯    â”‚â”€â”€â”€â”€â–¶â”‚  LangGraph SDK   â”‚â”€â”€â”€â”€â–¶â”‚  Python åç«¯    â”‚
â”‚   (ç«¯å£ 3000)   â”‚     â”‚                  â”‚     â”‚   (ç«¯å£ 2024)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                        â”‚                        â”‚
        â”‚                        â”‚                        â”‚
        â–¼                        â–¼                        â–¼
   ç”¨æˆ·ç•Œé¢ç•Œé¢              WebSocket/HTTP           Agentå¤„ç†é€»è¾‘
```

### æ ¸å¿ƒç»„ä»¶
- **å‰ç«¯**: Next.js + React + TypeScript
- **SDK**: `@langchain/langgraph-sdk`
- **åç«¯**: Python LangGraph + FastAPI
- **é€šä¿¡**: WebSocket + HTTP API

## ğŸ§  æ ¸å¿ƒæ¦‚å¿µ

### 1. Streamï¼ˆæµï¼‰
```typescript
// Stream æ˜¯æ ¸å¿ƒçš„è¿æ¥å¯¹è±¡ï¼Œç®¡ç†æ‰€æœ‰é€šä¿¡
const stream = useStreamContext();
```
- **ä½œç”¨**: ç®¡ç†å‰åç«¯ä¹‹é—´çš„å®æ—¶è¿æ¥
- **åŒ…å«**: æ¶ˆæ¯å†å²ã€åŠ è½½çŠ¶æ€ã€é”™è¯¯ä¿¡æ¯
- **æ–¹æ³•**: `submit()`, `stop()`, çŠ¶æ€è·å–

### 2. Threadï¼ˆä¼šè¯ï¼‰
```typescript
// Thread ä»£è¡¨ä¸€ä¸ªå®Œæ•´çš„å¯¹è¯ä¼šè¯
interface Thread {
  thread_id: string;
  created_at: string;
  updated_at: string;
  metadata: Record<string, any>;
}
```
- **ä½œç”¨**: ç»´æŠ¤å¯¹è¯ä¸Šä¸‹æ–‡å’Œå†å²
- **ç®¡ç†**: åˆ›å»ºã€æŸ¥è¯¢ã€åˆ‡æ¢ä¼šè¯

### 3. Messageï¼ˆæ¶ˆæ¯ï¼‰
```typescript
// Message æ˜¯å¯¹è¯çš„åŸºæœ¬å•ä½
interface Message {
  id: string;
  type: 'human' | 'ai' | 'tool' | 'system';
  content: string;
  created_at?: string;
}
```

## ğŸ› ï¸ ç¯å¢ƒå‡†å¤‡

### 1. å®‰è£…å‰ç«¯ä¾èµ–
```bash
# æ ¸å¿ƒSDK
npm install @langchain/langgraph-sdk @langchain/langgraph-sdk/react-ui

# è¾…åŠ©åº“ï¼ˆæ ¹æ®é¡¹ç›®éœ€è¦ï¼‰
npm install nuqs uuid use-stick-to-bottom sonner
```

### 2. å®‰è£…åç«¯ä¾èµ–
```bash
# Python ä¾èµ–
pip install langchain langchain-openai python-dotenv langgraph
```

### 3. ç¯å¢ƒå˜é‡é…ç½®
```env
# .env æ–‡ä»¶
OPENAI_API_KEY=your_openai_api_key
OPENAI_BASE_URL=your_base_url  # å¯é€‰ï¼Œå¦‚ä½¿ç”¨å…¶ä»–æ¨¡å‹
```

## âš™ï¸ åç«¯é…ç½®

### 1. åˆ›å»º Python Agent
```python
# apps/agents/src/app.py
from langchain_openai import ChatOpenAI
from langchain.agents import create_agent
from dotenv import load_dotenv

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

# åˆå§‹åŒ–æ¨¡å‹å’ŒAgent
llm = ChatOpenAI(model="gpt-4")
agent = create_agent(
    model=llm,
    system_prompt="You are a helpful assistant."
)

# å¯¼å‡ºagentå¯¹è±¡ï¼ˆå¿…é¡»ï¼‰
if __name__ == "__main__":
    state = agent.invoke({"messages": "Hello!"})
    print(state["messages"][-1].content)
```

### 2. é…ç½® LangGraph
```json
// langgraph.json
{
  "dependencies": ["."],
  "graphs": {
    "agent": "./apps/agents/src/app.py:agent"
  },
  "env": ".env"
}
```

**å…³é”®ç‚¹**:
- `"agent"` æ˜¯graph IDï¼Œå‰ç«¯ä¼šä½¿ç”¨è¿™ä¸ªID
- è·¯å¾„æŒ‡å‘Pythonæ–‡ä»¶ä¸­çš„agentå¯¹è±¡
- ä¸åŒ…å« `node_version`ï¼Œå› ä¸ºä½¿ç”¨Python

### 3. å¯åŠ¨åç«¯æœåŠ¡
```bash
langgraph dev --port 2024
```
æœåŠ¡å°†åœ¨ `http://localhost:2024` å¯åŠ¨

## ğŸ¨ å‰ç«¯å®ç°

### 1. åˆ›å»ºå®¢æˆ·ç«¯è¿æ¥
```typescript
// src/providers/client.ts
import { Client } from "@langchain/langgraph-sdk";

export function createClient(apiUrl: string, apiKey: string | undefined) {
  return new Client({
    apiKey,
    apiUrl,
  });
}
```

### 2. Stream Providerï¼ˆæ ¸å¿ƒï¼‰
```typescript
// src/providers/Stream.tsx
import React, { createContext, useContext } from "react";
import { useStream } from "@langchain/langgraph-sdk/react";

// ç±»å‹å®šä¹‰
export type StateType = {
  messages: Message[];
  ui?: UIMessage[];
};

const useTypedStream = useStream<StateType, /* ... */>;

// Stream Context
const StreamContext = createContext<ReturnType<typeof useTypedStream> | undefined>(undefined);

// å¥åº·æ£€æŸ¥å‡½æ•°
async function checkGraphStatus(apiUrl: string, apiKey: string | null): Promise<boolean> {
  try {
    const res = await fetch(`${apiUrl}/info`, {
      ...(apiKey && { headers: { "X-Api-Key": apiKey } }),
    });
    return res.ok;
  } catch (e) {
    console.error(e);
    return false;
  }
}

// Stream Provider ç»„ä»¶
export const StreamProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [apiUrl] = useQueryState("apiUrl");
  const [assistantId] = useQueryState("assistantId");
  const [apiKey] = useState(getApiKey() || "");

  const streamValue = useTypedStream({
    apiUrl: apiUrl || "http://localhost:2024",  // é»˜è®¤åœ°å€
    apiKey: apiKey || undefined,
    assistantId: assistantId || "agent",        // é»˜è®¤ID
    threadId: threadId ?? null,

    // å¤„ç†è‡ªå®šä¹‰äº‹ä»¶ï¼ˆå¦‚UIæ›´æ–°ï¼‰
    onCustomEvent: (event, options) => {
      options.mutate((prev) => {
        const ui = uiMessageReducer(prev.ui ?? [], event);
        return { ...prev, ui };
      });
    },

    // å¤„ç†æ–°threadåˆ›å»º
    onThreadId: (id) => {
      setThreadId(id);
    },
  });

  // å¥åº·æ£€æŸ¥
  useEffect(() => {
    checkGraphStatus(apiUrl, apiKey).then((ok) => {
      if (!ok) {
        toast.error("è¿æ¥å¤±è´¥", {
          description: `æ— æ³•è¿æ¥åˆ° ${apiUrl}`,
        });
      }
    });
  }, [apiUrl, apiKey]);

  return (
    <StreamContext.Provider value={streamValue}>
      {children}
    </StreamContext.Provider>
  );
};

// è‡ªå®šä¹‰Hook
export const useStreamContext = () => {
  const context = useContext(StreamContext);
  if (!context) {
    throw new Error("useStreamContext must be used within StreamProvider");
  }
  return context;
};
```

### 3. Thread Providerï¼ˆä¼šè¯ç®¡ç†ï¼‰
```typescript
// src/providers/Thread.tsx
import { createContext, useContext, useCallback } from "react";
import { Thread } from "@langchain/langgraph-sdk";
import { createClient } from "./client";

interface ThreadContextType {
  getThreads: () => Promise<Thread[]>;
  threads: Thread[];
  setThreads: Dispatch<SetStateAction<Thread[]>>;
}

const ThreadContext = createContext<ThreadContextType | undefined>(undefined);

export function ThreadProvider({ children }: { children: ReactNode }) {
  const [threads, setThreads] = useState<Thread[]>([]);
  const [apiUrl] = useQueryState("apiUrl");
  const [assistantId] = useQueryState("assistantId");

  const getThreads = useCallback(async (): Promise<Thread[]> => {
    if (!apiUrl || !assistantId) return [];

    const client = createClient(apiUrl, getApiKey());

    const threads = await client.threads.search({
      metadata: {
        // æ ¹æ®assistantIdç±»å‹é€‰æ‹©metadata
        ...(validate(assistantId)
          ? { assistant_id: assistantId }
          : { graph_id: assistantId }
        ),
      },
      limit: 100,
    });

    return threads;
  }, [apiUrl, assistantId]);

  return (
    <ThreadContext.Provider value={{ getThreads, threads, setThreads }}>
      {children}
    </ThreadContext.Provider>
  );
}

export function useThreads() {
  const context = useContext(ThreadContext);
  if (!context) {
    throw new Error("useThreads must be used within ThreadProvider");
  }
  return context;
}
```

### 4. èŠå¤©ç»„ä»¶å®ç°
```typescript
// src/components/Chat.tsx
import { useState } from "react";
import { useStreamContext } from "@/providers/Stream";
import { Message } from "@langchain/langgraph-sdk";
import { v4 as uuidv4 } from "uuid";

export function Chat() {
  const [input, setInput] = useState("");
  const stream = useStreamContext();
  const messages = stream.messages;
  const isLoading = stream.isLoading;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim() || isLoading) return;

    const newMessage: Message = {
      id: uuidv4(),
      type: "human",
      content: input,
    };

    // å‘é€æ¶ˆæ¯åˆ°åç«¯
    stream.submit(
      { messages: [...stream.messages, newMessage] },
      {
        streamMode: ["values"],  // å¯ç”¨æµå¼ä¼ è¾“
        optimisticValues: (prev) => ({
          ...prev,
          messages: [...(prev.messages ?? []), newMessage],
        }),
      }
    );

    setInput("");
  };

  return (
    <div>
      {/* æ¶ˆæ¯åˆ—è¡¨ */}
      <div>
        {messages.map((message) => (
          <div key={message.id}>
            <strong>{message.type}:</strong> {message.content}
          </div>
        ))}
      </div>

      {/* è¾“å…¥æ¡† */}
      <form onSubmit={handleSubmit}>
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="è¾“å…¥æ¶ˆæ¯..."
          disabled={isLoading}
        />
        <button type="submit" disabled={isLoading}>
          {isLoading ? "å‘é€ä¸­..." : "å‘é€"}
        </button>

        {isLoading && (
          <button type="button" onClick={() => stream.stop()}>
            åœæ­¢
          </button>
        )}
      </form>
    </div>
  );
}
```

## ğŸ”„ äº¤äº’æµç¨‹è¯¦è§£

### 1. åˆå§‹åŒ–è¿æ¥
```
1. ç”¨æˆ·è®¿é—®å‰ç«¯åº”ç”¨
2. StreamProvider åˆå§‹åŒ–
3. useStream hook å»ºç«‹WebSocketè¿æ¥
4. å‘é€å¥åº·æ£€æŸ¥åˆ° /info ç«¯ç‚¹
5. è¿æ¥æˆåŠŸï¼Œå‡†å¤‡æ¥æ”¶æ¶ˆæ¯
```

### 2. å‘é€æ¶ˆæ¯
```
1. ç”¨æˆ·è¾“å…¥æ¶ˆæ¯å¹¶ç‚¹å‡»å‘é€
2. åˆ›å»ºæ–°çš„Messageå¯¹è±¡
3. è°ƒç”¨ stream.submit() å‘é€åˆ°åç«¯
4. ä¹è§‚æ›´æ–°UIï¼ˆç«‹å³æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯ï¼‰
5. åç«¯å¤„ç†å¹¶è¿”å›AIå“åº”
6. é€šè¿‡WebSocketæµå¼è¿”å›ç»“æœ
7. å‰ç«¯å®æ—¶æ›´æ–°AIæ¶ˆæ¯
```

### 3. ä¼šè¯ç®¡ç†
```
1. é¦–æ¬¡å‘é€æ¶ˆæ¯æ—¶è‡ªåŠ¨åˆ›å»ºæ–°thread
2. onThreadId å›è°ƒæ›´æ–°URLä¸­çš„threadId
3. åç»­æ¶ˆæ¯åœ¨åŒä¸€threadä¸­å‘é€
4. å¯ä»¥åˆ‡æ¢ä¸åŒthreadæŸ¥çœ‹å†å²
5. ThreadProvider ç®¡ç†threadåˆ—è¡¨
```

## ğŸ“– å…³é”®ä»£ç åˆ†æ

### 1. useStream Hook å‚æ•°è¯¦è§£
```typescript
const stream = useStream({
  apiUrl: "http://localhost:2024",    // åç«¯æœåŠ¡åœ°å€
  apiKey: "your-api-key",            // APIå¯†é’¥ï¼ˆå¯é€‰ï¼‰
  assistantId: "agent",              // å›¾IDï¼Œå¯¹åº”langgraph.json
  threadId: "thread-123",            // ä¼šè¯IDï¼ˆå¯é€‰ï¼‰

  // æµæ¨¡å¼é…ç½®
  streamMode: ["values", "updates"], // è¿”å›å®Œæ•´çŠ¶æ€å’Œå¢é‡æ›´æ–°

  // å›è°ƒå‡½æ•°
  onThreadId: (id) => {              // æ–°threadåˆ›å»ºæ—¶
    console.log("New thread:", id);
  },

  onCustomEvent: (event, options) => { // è‡ªå®šä¹‰äº‹ä»¶
    // å¤„ç†UIæ›´æ–°ã€å·¥å…·è°ƒç”¨ç­‰
    options.mutate(prev => ({
      ...prev,
      ui: [...prev.ui, event]
    }));
  },

  // é”™è¯¯å¤„ç†
  onError: (error) => {
    console.error("Stream error:", error);
  }
});
```

### 2. Stream å¯¹è±¡å±æ€§
```typescript
const stream = {
  messages: Message[],      // æ‰€æœ‰æ¶ˆæ¯å†å²
  isLoading: boolean,       // æ˜¯å¦æ­£åœ¨åŠ è½½
  error: Error,            // é”™è¯¯ä¿¡æ¯
  interrupt: any,          // ä¸­æ–­ä¿¡æ¯

  // æ–¹æ³•
  submit: (values, options) => {},  // æäº¤æ¶ˆæ¯
  stop: () => {},                   // åœæ­¢å½“å‰æµ
  getValues: () => {},              // è·å–å½“å‰çŠ¶æ€
};
```

### 3. æ¶ˆæ¯ç±»å‹è¯´æ˜
```typescript
// Humanæ¶ˆæ¯ - ç”¨æˆ·è¾“å…¥
{
  id: "uuid",
  type: "human",
  content: "Hello, how are you?"
}

// AIæ¶ˆæ¯ - AIå“åº”
{
  id: "uuid",
  type: "ai",
  content: "I'm doing well, thank you!",
  tool_calls?: [...]  // å¯èƒ½åŒ…å«å·¥å…·è°ƒç”¨
}

// Toolæ¶ˆæ¯ - å·¥å…·æ‰§è¡Œç»“æœ
{
  id: "uuid",
  type: "tool",
  content: "Tool execution result",
  tool_call_id: "tool-uuid"
}
```

## ğŸ› ï¸ è‡ªå·±åŠ¨æ‰‹å®ç°

### æœ€å°ç‰ˆæœ¬å®ç°
```typescript
// MiniChat.tsx
import { useStream } from "@langchain/langgraph-sdk/react";
import { useState } from "react";

export function MiniChat() {
  const [input, setInput] = useState("");

  const stream = useStream({
    apiUrl: "http://localhost:2024",
    assistantId: "agent",
  });

  const sendMessage = () => {
    if (!input.trim()) return;

    stream.submit({
      messages: [{
        id: Date.now().toString(),
        type: "human",
        content: input
      }]
    });

    setInput("");
  };

  return (
    <div>
      {/* æ˜¾ç¤ºæ¶ˆæ¯ */}
      {stream.messages.map(msg => (
        <div key={msg.id}>
          <b>{msg.type}:</b> {msg.content}
        </div>
      ))}

      {/* è¾“å…¥æ¡† */}
      <div>
        <input
          value={input}
          onChange={e => setInput(e.target.value)}
          onKeyPress={e => e.key === 'Enter' && sendMessage()}
          placeholder="è¾“å…¥æ¶ˆæ¯..."
        />
        <button onClick={sendMessage}>å‘é€</button>
      </div>

      {/* çŠ¶æ€æ˜¾ç¤º */}
      {stream.isLoading && <div>AIæ­£åœ¨æ€è€ƒ...</div>}
      {stream.error && <div>é”™è¯¯: {stream.error.message}</div>}
    </div>
  );
}
```

### å®Œæ•´é¡¹ç›®ç»“æ„
```
your-project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ providers/
â”‚   â”‚   â”œâ”€â”€ Stream.tsx      # æµè¿æ¥ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ Thread.tsx      # ä¼šè¯ç®¡ç†
â”‚   â”‚   â””â”€â”€ client.ts       # å®¢æˆ·ç«¯å·¥å…·
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Chat.tsx        # èŠå¤©ç•Œé¢
â”‚   â”‚   â”œâ”€â”€ MessageList.tsx # æ¶ˆæ¯åˆ—è¡¨
â”‚   â”‚   â””â”€â”€ InputBox.tsx    # è¾“å…¥æ¡†
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ useChat.ts      # èŠå¤©é€»è¾‘Hook
â”‚   â””â”€â”€ app/
â”‚       â””â”€â”€ layout.tsx      # åº”ç”¨å¸ƒå±€
â”œâ”€â”€ apps/
â”‚   â””â”€â”€ agents/
â”‚       â””â”€â”€ src/
â”‚           â””â”€â”€ app.py      # Python Agent
â”œâ”€â”€ langgraph.json          # LangGraphé…ç½®
â””â”€â”€ package.json
```

## â“ å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•å¤„ç†è¿æ¥å¤±è´¥ï¼Ÿ
```typescript
useEffect(() => {
  checkGraphStatus(apiUrl, apiKey).then((ok) => {
    if (!ok) {
      // æ˜¾ç¤ºé”™è¯¯æç¤º
      // æä¾›é‡è¯•é€‰é¡¹
      // æ˜¾ç¤ºé…ç½®è¡¨å•
    }
  });
}, [apiUrl, apiKey]);
```

### Q2: å¦‚ä½•å®ç°æ¶ˆæ¯çš„æµå¼æ˜¾ç¤ºï¼Ÿ
```typescript
// AIæ¶ˆæ¯ä¼šè‡ªåŠ¨æµå¼æ›´æ–°
{messages.map(message => (
  message.type === "ai" && (
    <div key={message.id}>
      {message.content}  {/* å†…å®¹ä¼šå®æ—¶æ›´æ–° */}
    </div>
  )
))}
```

### Q3: å¦‚ä½•å¤„ç†å·¥å…·è°ƒç”¨ï¼Ÿ
```typescript
// åœ¨onCustomEventä¸­å¤„ç†
onCustomEvent: (event, options) => {
  if (event.type === 'tool_call') {
    // æ˜¾ç¤ºå·¥å…·è°ƒç”¨çŠ¶æ€
    // æ›´æ–°UI
  }
}
```

### Q4: å¦‚ä½•åˆ‡æ¢ä¸åŒçš„Agentï¼Ÿ
```typescript
// æ›´æ–°URLå‚æ•°å³å¯
setAssistantId("another-agent-id");
// Streamä¼šè‡ªåŠ¨é‡æ–°è¿æ¥
```

### Q5: å¦‚ä½•å®ç°æ¶ˆæ¯å†å²æŒä¹…åŒ–ï¼Ÿ
```typescript
// ä½¿ç”¨Thread API
const thread = await client.threads.create(metadata);
await client.threads.updateState(thread.thread_id, {
  values: { messages }
});
```

## ğŸ¯ å­¦ä¹ å»ºè®®

1. **å…ˆç†è§£æ¦‚å¿µ**: æŒæ¡Streamã€Threadã€Messageçš„æ¦‚å¿µ
2. **ä»ç®€å•å¼€å§‹**: å…ˆå®ç°æœ€å°ç‰ˆæœ¬ï¼Œå†é€æ­¥æ·»åŠ åŠŸèƒ½
3. **é˜…è¯»æºç **: æŸ¥çœ‹å®˜æ–¹SDKçš„å®ç°ç»†èŠ‚
4. **è°ƒè¯•å·¥å…·**: ä½¿ç”¨æµè§ˆå™¨å¼€å‘è€…å·¥å…·æŸ¥çœ‹WebSocketé€šä¿¡
5. **é”™è¯¯å¤„ç†**: åšå¥½é”™è¯¯å¤„ç†å’Œç”¨æˆ·æç¤º

## ğŸ“š è¿›é˜¶å­¦ä¹ 

- [LangGraph SDK æ–‡æ¡£](https://api.js.langchain.com/)
- [React Hooks æœ€ä½³å®è·µ](https://react.dev/learn)
- [WebSocket ç¼–ç¨‹æŒ‡å—](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
- [TypeScript è¿›é˜¶ç±»å‹](https://www.typescriptlang.org/docs/)

---

ç¥ä½ å­¦ä¹ é¡ºåˆ©ï¼æœ‰ä»»ä½•é—®é¢˜éƒ½å¯ä»¥ç»§ç»­æé—®ã€‚ğŸš€